% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dtedit.R
\name{dtedit}
\alias{dtedit}
\alias{dteditmod}
\title{Create a DataTable with Add, Edit and Delete buttons.}
\usage{
dtedit(input, output, name, thedata, ...)

dteditmod(
  input,
  output,
  session,
  thedata,
  view.cols = names(shiny::isolate(if (shiny::is.reactive(thedata)) {     thedata() }
    else {     thedata })),
  edit.cols = names(shiny::isolate(if (shiny::is.reactive(thedata)) {     thedata() }
    else {     thedata })),
  edit.label.cols = edit.cols,
  delete.info.cols = view.cols,
  delete.info.label.cols = delete.info.cols,
  input.types,
  input.choices = NULL,
  input.choices.reactive = NULL,
  inputEvent = NULL,
  action.buttons = NULL,
  selectize = TRUE,
  modal.size = "m",
  text.width = "100\%",
  textarea.width = "570px",
  textarea.height = "200px",
  date.width = "100px",
  datetime.width = "200px",
  numeric.width = "100px",
  select.width = "100\%",
  defaultPageLength = 10,
  max.fileInputLength = 1e+08,
  title.delete = "Delete",
  title.edit = "Edit",
  title.add = "New",
  label.delete = "Delete",
  label.edit = "Edit",
  label.add = "New",
  label.copy = "Copy",
  label.save = "Save",
  label.cancel = "Cancel",
  icon.delete = NULL,
  icon.edit = NULL,
  icon.add = NULL,
  icon.copy = NULL,
  text.delete.modal = "Are you sure you want to delete this record?",
  show.delete = TRUE,
  show.update = TRUE,
  show.insert = TRUE,
  show.copy = TRUE,
  callback.delete = function(data, row) { },
  callback.update = function(data, olddata, row) { },
  callback.insert = function(data, row) { },
  callback.actionButton = function(data, row, buttonID) { },
  click.time.threshold = 2,
  useairDatepicker = FALSE,
  datatable.options = list(pageLength = defaultPageLength),
  datatable.rownames = FALSE,
  datatable.call = function(...) {     DT::datatable(...) },
  ...
)
}
\arguments{
\item{input}{Shiny input object passed from the server.}

\item{output}{Shiny output object passed from the server.}

\item{name}{(\code{name} is available in \code{dtedit} only). The \code{name} of the
outputted editable datatable. The \code{name} passed to \code{dtedit} is the same
as the name passed to \code{uiOutput}. Put \code{uiOutput(name)} where you want the
editable datatable in the \code{ui.R}. When using more than one \code{dtedit} within a Shiny
application the name must be unique. (\code{name} is converted
to the \code{session} argument of dteditmod.)}

\item{thedata}{a data frame to view and edit. can be a reactive}

\item{...}{arguments not recognized by DTedit are passed to \code{DT::renderDataTable}
By default, \code{datatable.call} uses \code{DT::dataframe}, so this limits the options that
can be passed through this method.}

\item{session}{Shiny session object (an environment) passed from the server.
Alternatively, the 'name' (character) of the outputted editable datatable.}

\item{view.cols}{character vector with the column names to show in the DataTable.
This can be a subset of the full \code{data.frame}.}

\item{edit.cols}{character vector with the column names the user can edit/add.
This can be a subset of the full \code{data.frame}.}

\item{edit.label.cols}{character vector with the labels to use on the edit
and add dialogs. The length and order of \code{code.cols.labels} must
correspond to \code{edit.cols}.}

\item{delete.info.cols}{character vector with the column names specifying
which values are presented on the delete dialog.
This can be a subset of the full \code{data.frame}. Defaults to \code{view.cols}.
If \code{NULL}, no data values are shown on the delete dialog.}

\item{delete.info.label.cols}{character vector with the labels to use on the delete
dialog. The length and order of \code{delete.info.label.cols} must
correspond to \code{delete.info.cols}.}

\item{input.types}{a character vector where the name corresponds to a column
in \code{edit.cols} and the value is the input type. Possible values
are:
\itemize{
\item \code{dateInput} - input changed by \code{date.width}
\item \code{datetimeInput} - input changed by \code{datetime.width}. needs
\code{useairDatepicker} set to \code{TRUE} and requires package \code{shinyWidgets}.
\item \code{selectInput} - choices determined by \code{input.choices},
or the levels of the data column
variable (if the column variable is of class \code{factor}),
or the already present values in the data column.
\item \code{selectInputMultiple} - choices determined by
\code{input.choices} or the already present values in the data
column.
\item \code{selectInputReactive} - choices determined by a reactive
variable, as defined by \code{input.choices} and
\code{input.choices.reactive}.
\item \code{selectInputMultipleReactive} - choices determined by a
reactive variable, as defined by \code{input.choices} and
\code{input.choices.reactive}
\item \code{numericInput} - input changed by \code{numeric.width}
\item \code{textInput} - input changed by \code{text.width}
\item \code{textAreaInput} - input changed by \code{textarea.width} and \code{textarea.height}
\item \code{passwordInput}
\item \code{fileInput} - type of acceptable file types is defined by
\code{input.choices}. Maximum file length is modifed by
\code{max.fileInputLength}
}

One case where this parameter is desirable is when a text
area is required instead of a simple text input.}

\item{input.choices}{a list of character vectors. The names of each element
in the list must correspond to a column name in the data. The value,
a character vector, are the options presented to the user for data entry,
in the case of input type \code{selectInput}).

In the case of input type \code{selectInputReactive}
or `selectInputMultipleReactive``, the value is the name
of the reactive in 'input.choices.reactive'

In the case of input type `fileInput`` this is the
'accept' argument, which specifies the type of file which
is acceptable. Can be a case insensitive file extension
(e.g. '.csv' or '.rds') or a MIME type (e.g. 'text/plain' or
'application/pdf').}

\item{input.choices.reactive}{a named list of reactives, referenced in
\code{input.choices} to use for input type \code{selectInputReactive} or
\code{selectInputMultipleReactive}. The reactive itself is a character
vector.}

\item{inputEvent}{a named list of functions. The names of each element in
the list must correspond to an editable column name in the data. The
function is called when the associated input widget event is observed
during editing/adding a data row. Can be used, for example,
with \code{shinyFeedback}.}

\item{action.buttons}{a named list of action button columns.
Each column description is a list of \code{columnLabel}, \code{buttonLabel},
\code{buttonPrefix}, \code{afterColumn}.
\itemize{
\item \code{columnLabel} label used for the column.
\item \code{buttonLabel} label used for each button
\item \code{buttonPrefix} used as the prefix for action button IDs.
The suffix will be a number from '1' to the number of rows.
Prefix and suffix will be separated with an underscore '_'.
\item \code{afterColumn} if provided, the action button column is
placed after this named column.
}}

\item{selectize}{Whether to use \code{selectize.js} or not. See \code{\link{selectInput}} for more info.}

\item{modal.size}{the size of the modal dialog. See \code{\link{modalDialog}}.}

\item{text.width}{width of text inputs.}

\item{textarea.width}{the width of text area inputs.}

\item{textarea.height}{the height of text area inputs.}

\item{date.width}{the width of data inputs}

\item{datetime.width}{the width of datetime inputs}

\item{numeric.width}{the width of numeric inputs.}

\item{select.width}{the width of drop down inputs.}

\item{defaultPageLength}{number of rows to show in the data table by default.}

\item{max.fileInputLength}{the maximum length (in bytes) of \code{fileInput}.
Shiny itself has a default limit of 5 megabytes per file.
The limit can be modified by using shiny.maxRequestSize option.}

\item{title.delete}{the title of the dialog box for deleting a row.}

\item{title.edit}{the title of the dialog box for editing a row.}

\item{title.add}{the title of the dialog box for inserting a new row.}

\item{label.delete}{the label of the delete button.}

\item{label.edit}{the label of the edit button.}

\item{label.add}{the label of the add button.}

\item{label.copy}{the label of the copy button.}

\item{label.save}{the label of the save button.}

\item{label.cancel}{the label of the cancel button.}

\item{icon.delete}{the icon for the delete button, e.g. \code{icon("trash")}.
Defaults to \code{NULL}.}

\item{icon.edit}{the icon for the edit button, e.g. \code{icon("edit")}.
Defaults to \code{NULL}.}

\item{icon.add}{the icon for the add button, e.g. \code{icon("plus")}.
Defaults to \code{NULL}.}

\item{icon.copy}{the icon for the copy button, e.g. \code{icon("copy")}.
Defaults to \code{NULL}.}

\item{text.delete.modal}{the text shown in the delete modal dialog.}

\item{show.delete}{whether to show/enable the delete button.}

\item{show.update}{whether to show/enable the update button.}

\item{show.insert}{whether to show/enable the insert button.}

\item{show.copy}{whether to show/enable the copy button.}

\item{callback.delete}{a function called when the user deletes a row.
This function should return an updated data.frame.}

\item{callback.update}{a function called when the user updates a row.
This function should return an updated data.frame.}

\item{callback.insert}{a function called when the user inserts a new row.
This function should return an updated data.frame.}

\item{callback.actionButton}{a function called when the user clicks an action button.
called with arguments \code{data}, \code{row} and \code{buttonID}.
This function can return an updated data.frame,
alternatively return NULL if data is not to be changed.}

\item{click.time.threshold}{This is to prevent duplicate entries usually by
double clicking the save or update buttons. If the user clicks the save
button again within this amount of time (in seconds), the subsequent click
will be ignored (using \code{shiny::throttle}). Set to zero to disable this
feature.}

\item{useairDatepicker}{use \code{shinyWidgets} package \code{airDatepickerInput}}

\item{datatable.options}{options passed to \code{DT::renderDataTable}.
See \url{https://rstudio.github.io/DT/options.html} for more information.}

\item{datatable.rownames}{show rownames as part of the datatable? \code{TRUE} or \code{FALSE}.
Note that if datatable.call includes \verb{DT::format*} calls,
then \code{datatable.rownames} must equal \code{TRUE}}

\item{datatable.call}{pre-processing call when calling \code{DT::renderDataTable}.
Can be defined, for example, to include \verb{DT::format*} calls.
\code{dtedit} will pass several arguments to the \code{datatable.call} function.
\itemize{
\item \code{data} a dataframe. may have been processed to add \code{actionButtons}
\item \code{options} - \code{datatable.options}
\item \code{rownames} - \code{datatable.rownames}
\item \code{escape} - escape all columns except those with action buttons.
\item \code{selection} - \code{single}
}}
}
\value{
Returns reactiveValues
\itemize{
\item \code{theData} - the current state of \code{DTedit}'s copy of the data
\item \code{view.cols}
\item \code{edit.cols}
\item \code{edit.count} - number of edits to data done within \code{DTedit} (does not
include changes to \code{DTedit}'s copy of the data secondary to changes
of a reactive \code{thedata})
\item \code{rows_selected} - the row number selected. initially set to \code{NULL}
}
}
\description{
dtedit - editable DataTable

dteditmod - editable DataTable, adapted for use in modules
}
\details{
\code{dtedit} is used in conjunction with \code{uiOutput} to create editable datatables.
\code{dtedit} is used in a shiny application's server definition, \code{uiOutput} is used
in the UI (user interface) definition.

\code{dteditmod} is used in conjunction with \code{callModule} and
\code{dteditmodUI} to create editable datatables in a module environment.
\code{dteditmod} is called through \code{callModule} in the 'server' section of
the shiny application.
\code{dteditmodUI} is called in the 'UI' (user-interface) section of the shiny app.

This object will maintain data state. However, in order of the data to persist
between Shiny instances, data needs to be saved to some external format (e.g.
database or R data file). The callback functions provide a mechanism for this
function to interact with a permanent data storage scheme. The callback
functions are called when the user adds, updates, or deletes a row from the
data table. The callback must accept two parameters: \code{data} and \code{row}.
For inserting and updating, the \code{data} object is the current state of
data table including any additions or updates. The \code{row} parameter indicates
which row from \code{data} was modified (or added). For deletions, however,
the \code{data} represents the data table just before deleting the specified
row. That is, if \code{callback.delete} returns a \code{data.frame}, that will
be the new data table; otherwise this function will remove row \code{row} from
\code{data} and that will become the current data table.

The callback functions may throw errors (see e.g. \code{stop}) if there are
problems with data. That is, if data validation checks indicate data problems
before inserting or updating a row the function may throw an error. Note that
the error message will be presented to the user so providing messages
meaningful to the user is recommended. Moreover, if an error is thrown, the
modal dialog is not dismissed and the user can further edit the data and
retry the insertion or update.

Callback functions may return a \code{data.frame}. When a \code{data.frame} is
returned that will become the current state of the data table. If anything
else is returned then the internal \code{data.frame} will be used.
}
\examples{
# minimal DTedit example 'dtedit'
# you can try this example in interactive mode
# with 'example("dtedit")'

library(shiny)
library(DTedit)

server <- function(input, output) {
  
  Grocery_List <- dtedit(
    input, output,
    name = 'Grocery_List',
    thedata = data.frame(
      Buy = c('Tea', 'Biscuits', 'Apples'),
      Quantity = c(7, 2, 5),
      stringsAsFactors = FALSE
    )
  )
}

ui <- fluidPage(
  h3('Grocery List'),
  uiOutput('Grocery_List')
)

if (interactive())
  shinyApp(ui = ui, server = server)

#### end of 'dtedit' example ####


# minimal DTedit example 'dteditmod'
# this is a separate application from the 'dtedit' example!
#
# unfortunately, this application cannot be
# tried with 'example("dteditmod")', but you can copy
# and paste to execute in 'interactive' console mode,
# or copy the lines into an '.R' file and choose
# 'Run App' from RStudio.
library(shiny)
library(DTedit)

myModuleUI <- function(id) {
  ns <- shiny::NS(id)
  shiny::tagList(
    dteditmodUI(ns('Grocery_List'))
  )
}

myModule <- function(input, output, session) {
  Grocery_List_Results <- shiny::callModule(
    dteditmod,
    id = 'Grocery_List',
    thedata = data.frame(
      Buy = c('Tea', 'Biscuits', 'Apples'),
      Quantity = c(7, 2, 5),
      stringsAsFactors = FALSE
    )
  )
}

server <- function(input, output, session) {

  shiny::callModule(myModule, 'myModule1')

}

ui <- fluidPage(
  h3('Grocery List'),
  myModuleUI('myModule1')
)

if (interactive() || isTRUE(getOption("shiny.testmode")))
  shinyApp(ui = ui, server = server)
}
\seealso{
\itemize{
 \item \code{example("dtedit")} a simple example.
 \item \code{dtedit_demo()} demonstration of dtedit.
 \item \code{dtedit_reactive_demo()} reactive dataframe
 \item \code{dtedit_selectInputReactive_demo()} reactive selectInput
 }

\itemize{
\item \code{\link{dteditmodUI}} : the companion user-interface function for \code{dteditmod}.\cr
\item \code{example("dteditmodUI")} a simple module example with reactive dataframe
\item \code{dteditmod_demo()} a more complex module example. Database interaction
and interactions between the data of multiple datatables.
\item \code{dteditmod_fileInput_demo()} a modular example including binary file input and action buttons.
}

Other Datatable Edit functions: 
\code{\link{dteditmodUI}()}
}
\concept{Datatable Edit functions}
